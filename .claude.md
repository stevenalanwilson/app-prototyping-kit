# App Prototyping Kit - Claude Context

## Project Overview

This is a production-ready React + TypeScript starter kit optimized for rapid MVP development. It provides a complete foundation with working examples, modern tooling, and clear patterns to follow.

**Purpose:** Enable developers to build and ship MVPs in days, not weeks, without sacrificing code quality.

## Tech Stack

- **Frontend:** React 18.2, TypeScript 5.3, Vite 5.0
- **Styling:** Tailwind CSS 3.4, Radix UI (accessible headless components)
- **State Management:** TanStack Query 5 (server state), Zustand 4.5 (client state)
- **Forms:** React Hook Form 7, Zod 3.22 (validation)
- **Routing:** React Router 6.21
- **Testing:** Vitest 1.2, Testing Library 14
- **Code Quality:** ESLint 8.56, Prettier 3.2

## Project Architecture

### Core Philosophy

1. **Speed over perfection** - Optimize for rapid iteration
2. **Simple patterns** - One obvious way to do things
3. **Type safety** - TypeScript strict mode catches bugs early
4. **Production-ready** - No prototype shortcuts, build it right

### Directory Structure

```
src/
├── components/
│   ├── layout/          # App shell (Header, Sidebar, Layout)
│   └── ui/              # Reusable components (Button, Input, Card, Modal, etc.)
├── pages/               # Route handlers (one per route)
├── hooks/               # Custom React hooks (data fetching with React Query)
├── lib/                 # Non-React utilities
│   ├── api.ts          # API client (currently mock, replace with real)
│   ├── queryClient.ts  # TanStack Query configuration
│   └── utils.ts        # Helper functions (cn, formatDate, etc.)
├── stores/              # Zustand stores for client state
├── styles/              # Global CSS and Tailwind
├── test/                # Test utilities and setup
└── types/               # Shared TypeScript types
```

### Key Patterns

#### Data Fetching Pattern

**Location:** `src/hooks/use[Resource].ts`

```typescript
// 1. Define API methods in lib/api.ts
export const api = {
  items: {
    list: async (): Promise<Item[]> => { /* ... */ },
    create: async (data: Omit<Item, 'id'>): Promise<Item> => { /* ... */ },
  }
}

// 2. Create React Query hooks
export function useItems() {
  return useQuery({
    queryKey: ['items'],
    queryFn: api.items.list,
  })
}

export function useCreateItem() {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: api.items.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['items'] })
    },
  })
}
```

#### Form Pattern

**Location:** Page components (e.g., `src/pages/CreateItemPage.tsx`)

```typescript
// 1. Define Zod schema
const schema = z.object({
  name: z.string().min(3),
  email: z.string().email(),
})

// 2. Setup React Hook Form
const { register, handleSubmit, formState: { errors } } = useForm({
  resolver: zodResolver(schema)
})

// 3. Handle submission with mutation
const createMutation = useCreateItem()
const onSubmit = async (data) => {
  await createMutation.mutateAsync(data)
  toast({ title: 'Success' })
}
```

#### Component Pattern

**Location:** `src/components/ui/`

- Use TypeScript interfaces for props
- Use `forwardRef` for components wrapping native elements
- Support `className` prop with `cn()` utility for customization
- Use object mapping for variants
- Include loading/disabled states

#### State Management

- **Server state:** React Query (items, users, any API data)
- **Client state:** Zustand (UI state like sidebar open/closed)
- **Form state:** React Hook Form (temporary input values)
- **Local state:** useState (component-specific state)

## File Conventions

### Naming

- **Components:** PascalCase (`Button.tsx`, `ItemsPage.tsx`)
- **Hooks:** camelCase with `use` prefix (`useItems.ts`)
- **Utilities:** camelCase (`api.ts`, `utils.ts`)
- **Tests:** Same as source + `.test` suffix (`Button.test.tsx`)

### Import Aliases

Use `@/` for all src imports:
```typescript
import { Button } from '@/components/ui/Button'
import { useItems } from '@/hooks/useItems'
```

### Component Structure

```typescript
import { forwardRef } from 'react'
import { cn } from '@/lib/utils'

export interface ComponentProps extends HTMLAttributes<HTMLElement> {
  variant?: 'primary' | 'secondary'
  // ... props
}

export const Component = forwardRef<HTMLElement, ComponentProps>(
  ({ variant = 'primary', className, ...props }, ref) => {
    return (
      <element
        ref={ref}
        className={cn('base-classes', variantStyles[variant], className)}
        {...props}
      />
    )
  }
)

Component.displayName = 'Component'
```

## Common Tasks

### Adding a New Resource

1. Define interface in `src/lib/api.ts`
2. Add mock data and API methods in `src/lib/api.ts`
3. Create hooks in `src/hooks/use[Resource].ts`
4. Create page in `src/pages/[Resource]Page.tsx`
5. Add route in `src/App.tsx`
6. Add nav link in `src/components/layout/Sidebar.tsx`

**Reference:** See `useItems.ts` and `ItemsPage.tsx` for complete example

### Adding a New Page

1. Create component in `src/pages/[Name]Page.tsx`
2. Add route in `src/App.tsx`: `<Route path="/path" element={<Page />} />`
3. Update sidebar navigation if needed

### Adding a New Form

1. Define Zod schema for validation
2. Setup `useForm` with `zodResolver`
3. Create mutation hook
4. Use UI components (`Input`, `Select`, `Button`)
5. Handle submission with try/catch and toasts

**Reference:** See `CreateItemPage.tsx` for complete example

### Adding a New Component

1. Create in `src/components/ui/[Name].tsx`
2. Define Props interface
3. Use forwardRef if wrapping native element
4. Support className for customization
5. Add variants if needed
6. Export from file

**Reference:** See `Button.tsx` for best practices

## Important Notes

### Mock API

`src/lib/api.ts` currently uses **mock data** with simulated delays. Replace with real API calls:

```typescript
// Replace this:
await delay(500)
return mockItems

// With this:
const response = await fetch(`${API_URL}/items`)
return response.json()
```

### Environment Variables

Use `.env` files for configuration:
```typescript
const API_URL = import.meta.env.VITE_API_URL
```

### Testing

- Use `vitest` for unit tests
- Use `@testing-library/react` for component tests
- Use `renderWithProviders` from `src/test/utils.tsx` for components using React Query/Router
- Focus on user behavior, not implementation details

### Code Quality

Run before committing:
```bash
npm run typecheck  # Check TypeScript
npm run lint       # Check ESLint
npm run format     # Format with Prettier
npm test           # Run tests
```

## Working Examples

The codebase includes complete, working examples:

- **ItemsPage.tsx** - List view with delete functionality
- **CreateItemPage.tsx** - Form with validation and error handling
- **useItems.ts** - React Query hooks (queries and mutations)
- **Button.tsx** - Component with variants, tests, and best practices

**These are templates to copy and modify, not just reference code.**

## Documentation

Comprehensive guides in `docs/`:
- **START_HERE.md** - Documentation navigation
- **GET_STARTED.md** - 3-step tutorial
- **QUICK_START.md** - Common tasks and recipes
- **DEVELOPMENT.md** - Patterns and architecture
- **PROJECT_STRUCTURE.md** - File organization
- **CHECKLIST.md** - Step-by-step guides

## Development Workflow

1. Start dev server: `npm run dev` (opens http://localhost:3000)
2. Make changes (HMR updates instantly)
3. Check types: `npm run typecheck`
4. Run tests: `npm test`
5. Format code: `npm run format`
6. Commit and push

## Key Design Decisions

### Why TanStack Query?
- Eliminates data fetching boilerplate
- Automatic caching and background refetching
- Optimistic updates out of the box
- Perfect for rapid prototyping

### Why Zustand over Redux?
- Minimal boilerplate (no actions, reducers, providers)
- ~1KB bundle size
- TypeScript-first design
- Use only for transient UI state

### Why React Hook Form?
- Minimal re-renders (uncontrolled forms)
- Best performance for forms
- Easy Zod integration
- Works seamlessly with Radix UI components

### Why Radix UI?
- Unstyled, accessible primitives
- Full keyboard navigation
- ARIA attributes handled automatically
- Style with Tailwind as needed

## Common Pitfalls to Avoid

❌ **Don't** create new patterns - follow existing examples
❌ **Don't** use relative imports - use `@/` alias
❌ **Don't** select entire Zustand store - select only what you need
❌ **Don't** put server state in Zustand - use React Query
❌ **Don't** create abstractions prematurely - keep it simple

✅ **Do** copy and modify existing examples
✅ **Do** use TypeScript strictly
✅ **Do** validate forms with Zod
✅ **Do** handle errors with try/catch and toasts
✅ **Do** keep components focused and small

## Performance Considerations

- Routes are not lazy-loaded by default (add if bundle gets large)
- React Query has sensible defaults (5min staleTime)
- Zustand selectors prevent unnecessary re-renders
- Tailwind purges unused CSS in production
- Vite optimizes builds automatically

## When Assisting with This Codebase

1. **Follow existing patterns** - Don't introduce new architectures
2. **Use working examples** - Reference ItemsPage, CreateItemPage, useItems
3. **Keep it simple** - This is for rapid prototyping, not complex systems
4. **Maintain type safety** - Always use TypeScript properly
5. **Think about velocity** - Fast iteration is the priority
6. **Reference docs** - Point users to relevant documentation when helpful

## Quick Reference Commands

```bash
npm run dev          # Start dev server
npm run build        # Production build
npm test             # Run tests
npm run typecheck    # Check types
npm run lint         # Lint code
npm run format       # Format code
```

This codebase is designed to get from idea to deployed MVP as quickly as possible while maintaining production-quality code.
